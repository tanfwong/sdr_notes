
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2.2. Elementary Multi-threading &#8212; Digital Communications with SDRs</title>
    
  <link rel="stylesheet" href="_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="canonical" href="wing.ece.ufl.edu/eel6528/multithread.html" />
    <link rel="shortcut icon" href="_static/logo.png"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2.3. References and further reading" href="prelims_exs.html" />
    <link rel="prev" title="2.1. UHD" href="uhd.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />


<!-- Opengraph tags -->
<meta property="og:url"         content="wing.ece.ufl.edu/eel6528/multithread.html" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="Elementary Multi-threading" />
<meta property="og:description" content="Elementary Multi-threading  To implement a communication system, we usually need to run functions that send and/or receive signal samples to and/or from the USR" />
<meta property="og:image"       content="wing.ece.ufl.edu/eel6528/_static/logo.png" />

<meta name="twitter:card" content="summary" />


  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
  
  <img src="_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Digital Communications with SDRs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   EEL6528 Digital Communications with Software Defined Radios
  </a>
 </li>
</ul>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="introduction.html">
   1. Introduction
  </a>
 </li>
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="prelims.html">
   2. Some Programming Prelims
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="uhd.html">
     2.1. UHD
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     2.2. Elementary Multi-threading
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="prelims_exs.html">
     2.3. References and further reading
    </a>
   </li>
   <li class="toctree-l2 collapsible-parent">
    <a class="reference internal" href="prelims_exs.html#code-examples">
     2.4. Code Examples
    </a>
    <ul class="collapse-ul">
     <li class="toctree-l3">
      <a class="reference internal" href="uhd_safe_main.html">
       2.4.1.
       <code class="docutils literal notranslate">
        <span class="pre">
         uhd_safe_main.hpp
        </span>
       </code>
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="age.html">
       2.4.2.
       <code class="docutils literal notranslate">
        <span class="pre">
         age.cpp
        </span>
       </code>
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="txrx_setup.html">
       2.4.3.
       <code class="docutils literal notranslate">
        <span class="pre">
         txrx_loopback_to_file.cpp
        </span>
       </code>
       (setup)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="txrx_stream.html">
       2.4.4.
       <code class="docutils literal notranslate">
        <span class="pre">
         txrx_loopback_to_file.cpp
        </span>
       </code>
       (stream)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="stream.html">
       2.4.5.
       <code class="docutils literal notranslate">
        <span class="pre">
         stream.hpp
        </span>
       </code>
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="tx_samples_from_file.html">
       2.4.6.
       <code class="docutils literal notranslate">
        <span class="pre">
         tx_samples_from_file.cpp
        </span>
       </code>
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="txrx_TX.html">
       2.4.7.
       <code class="docutils literal notranslate">
        <span class="pre">
         txrx_loopback_to_file.cpp
        </span>
       </code>
       (TX)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="txrx_RX.html">
       2.4.8.
       <code class="docutils literal notranslate">
        <span class="pre">
         txrx_loopback_to_file.cpp
        </span>
       </code>
       (RX)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="age_threads.html">
       2.4.9.
       <code class="docutils literal notranslate">
        <span class="pre">
         age_threads.cpp
        </span>
       </code>
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="txrx_thread.html">
       2.4.10.
       <code class="docutils literal notranslate">
        <span class="pre">
         txrx_loopback_to_file.cpp
        </span>
       </code>
       (thread)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="age_mutex.html">
       2.4.11.
       <code class="docutils literal notranslate">
        <span class="pre">
         age_mutex.cpp
        </span>
       </code>
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="age_mutex_caller.html">
       2.4.12.
       <code class="docutils literal notranslate">
        <span class="pre">
         age_mutex_caller.cpp
        </span>
       </code>
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="count_atomic.html">
       2.4.13.
       <code class="docutils literal notranslate">
        <span class="pre">
         count_atomic.cpp
        </span>
       </code>
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="queue.html">
       2.4.14.
       <code class="docutils literal notranslate">
        <span class="pre">
         queue.hpp
        </span>
       </code>
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="age_fifo.html">
       2.4.15.
       <code class="docutils literal notranslate">
        <span class="pre">
         age_fifo.cpp
        </span>
       </code>
      </a>
     </li>
    </ul>
    <i class="fas fa-chevron-down">
    </i>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="filter.html">
   3. Multi-rate Filtering
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="fftw3.html">
     3.1. FFTW3 Library
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="filter_exs.html">
     3.2. References and further reading
    </a>
   </li>
   <li class="toctree-l2 collapsible-parent">
    <a class="reference internal" href="filter_exs.html#code-examples">
     3.3. Code Examples
    </a>
    <ul class="collapse-ul">
     <li class="toctree-l3">
      <a class="reference internal" href="fft.html">
       3.3.1.
       <code class="docutils literal notranslate">
        <span class="pre">
         fft.hpp
        </span>
       </code>
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="test_fft.html">
       3.3.2.
       <code class="docutils literal notranslate">
        <span class="pre">
         test_fft.cpp
        </span>
       </code>
      </a>
     </li>
    </ul>
    <i class="fas fa-chevron-down">
    </i>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/multithread.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#create-launch-and-join-threads">
   2.2.1. Create, launch, and join threads
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#uhd-thread-priority">
   2.2.2. UHD thread priority
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#thread-synchronization-with-mutex">
   2.2.3. Thread synchronization with mutex
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#internal-locking">
     2.2.3.1. Internal locking
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#caller-ensured-locking">
     2.2.3.2. Caller-ensured locking
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#internal-caller-ensured-locking">
     2.2.3.3. Internal + Caller-ensured locking
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#passing-information-signal-between-threads-using-atomic-objects">
   2.2.4. Passing information/signal between threads using atomic objects
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#thread-safe-fifo-queue">
   2.2.5. Thread-safe FIFO queue
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="elementary-multi-threading">
<span id="sec-multithread"></span><h1><span class="section-number">2.2. </span>Elementary Multi-threading<a class="headerlink" href="#elementary-multi-threading" title="Permalink to this headline">¶</a></h1>
<ul>
<li><p>To implement a communication system, we usually need to run
functions that send and/or receive signal samples to and/or from the
USRP as well as many other processing functions asynchronously and
simultaneously.</p></li>
<li><p>This can be done by multi-threaded programming, in which different
functions are implemented in different threads. Exactly how many
treads to use and which functions should be implemented in which
threads are typical design questions.</p></li>
<li><p>Multi-threading imposes overheads. If you are pushing the CPU to its
limits and concern about overheads, a common rule of thumb is to
have the maximum number of simultaneous CPU-hogging threads to be
roughly the same as the number of processors (or cores)
available. In our Linux boxes, all the processors contain 4 cores
with hyper-threading support. Hence the maximum of number of
simultaneous CPU-hogging threads should be about 8.</p></li>
<li><p>Generally we should have a main thread, the one starts <code class="docutils literal notranslate"><span class="pre">main()</span></code>, and
other spawned threads. We will use the
<a class="reference external" href="http://www.cplusplus.com/reference/thread/thread/"><code class="docutils literal notranslate"><span class="pre">std::thread</span></code></a>
class to create, launch, and manage threads.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p><code class="docutils literal notranslate"><span class="pre">std::thread</span></code> is available in C++11 or after.</p>
</div>
<div class="admonition-dig-deeper admonition">
<p class="admonition-title">Dig deeper</p>
<p>You may also use the more powerful
<a class="reference external" href="https://www.boost.org/doc/libs/1_71_0/doc/html/thread.html">Boost.Thread</a>
library to do multi-threading.</p>
</div>
</li>
</ul>
<div class="section" id="create-launch-and-join-threads">
<h2><span class="section-number">2.2.1. </span>Create, launch, and join threads<a class="headerlink" href="#create-launch-and-join-threads" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>The simplest way to create and launch a thread is to instantiate a
<code class="docutils literal notranslate"><span class="pre">std::thread</span></code> class object by passing to its constructor a function
pointer pointing to the function that the thread is to
execute. Other input arguments of the function can also be passed to
the constructor. See the code example below.</p></li>
<li><p>After a thread is completed, we should <strong>join</strong> the thread back to
the main thread for clean termination. This is done by the using
<code class="docutils literal notranslate"><span class="pre">std::thread::join()</span></code> method, which will block the calling thread
until the thread represented by the thread object has completed. To
make sure that a thread can be joined, we may check if the thread is
“joinable” using the <code class="docutils literal notranslate"><span class="pre">std::thread::joinable()</span></code> method. A thread is
not “joinable” if it has been already joined or detached.</p></li>
<li><p>One may use the namespace <code class="docutils literal notranslate"><span class="pre">std::this_thread</span></code> to invoke a set of
functions that access the current thread. For example, calling the
<code class="docutils literal notranslate"><span class="pre">std::this_thread::sleep_for()</span></code> method will cause the current thread
to pause for a specified amount of time. We should always try to do
that whenever possible in a thread to vacate CPU resources to other
running threads.</p></li>
<li><p><u>Example</u>: <a class="reference internal" href="age_threads.html#code-age-threads"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">age_threads.cpp</span></code></span></a></p>
<div class="admonition-dig-deeper admonition">
<p class="admonition-title">Dig deeper</p>
<p>To see a more complicated example using the Boost.Thread library
with the
<a class="reference external" href="https://www.boost.org/doc/libs/1_71_0/doc/html/thread/thread_management.html#thread.thread_management.threadgroup"><code class="docutils literal notranslate"><span class="pre">boost::thread_group</span></code></a>
class and
<a class="reference external" href="https://www.boost.org/doc/libs/1_71_0/libs/bind/doc/html/bind.html">Boost.Bind</a>
library, check out <a class="reference internal" href="txrx_thread.html#code-txrx-thread"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">txrx_loopback_to_file.cpp</span></code></span></a></p>
</div>
</li>
</ul>
</div>
<div class="section" id="uhd-thread-priority">
<h2><span class="section-number">2.2.2. </span>UHD thread priority<a class="headerlink" href="#uhd-thread-priority" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>The priority of the main thread can be set using the
<code class="docutils literal notranslate"><span class="pre">uhd::set_thread_priority_safe()</span></code> method in <code class="docutils literal notranslate"><span class="pre">main()</span></code>. The same
method can be used to set the thread priority in the function that a
spawned thread executes. The <code class="docutils literal notranslate"><span class="pre">uhd::set_thread_priority_safe()</span></code>
method is a UHD wrapper to set thread priority using
<a class="reference external" href="https://computing.llnl.gov/tutorials/pthreads/">Pthreads</a> in
UNIX-based systems. The <code class="docutils literal notranslate"><span class="pre">gcc</span></code> compiler, in most of such systems,
implements the <code class="docutils literal notranslate"><span class="pre">std::thread</span></code> class based on Pthreads. Hence, you may
also use the same method to set priority of threads that you create
using <code class="docutils literal notranslate"><span class="pre">std::thread</span></code>. This also applies if you use the Boost.Thread
library instead.</p></li>
<li><p>The two input parameters of <code class="docutils literal notranslate"><span class="pre">uhd::set_thread_priority_safe()</span></code> are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">priority</span></code>: a <code class="docutils literal notranslate"><span class="pre">float</span></code> in [0,1] with 0 and 1 respectively meaning lowest and highest priority for the thread (default = 0.5)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">realtime</span></code>: a <code class="docutils literal notranslate"><span class="pre">bool</span></code> specifying whether real-time scheduling should be enabled or not (default = <code class="docutils literal notranslate"><span class="pre">true</span></code>)</p></li>
</ul>
</li>
<li><p>Setting <code class="docutils literal notranslate"><span class="pre">priority</span></code> to 1 and <code class="docutils literal notranslate"><span class="pre">realtime</span></code> to <code class="docutils literal notranslate"><span class="pre">true</span></code> typically gives the thread
highest priority. This is what we want to do for threads that
implement time-critical processing, such as sending samples from the
host to the USRP and grabbing samples back to the host from the
USRP.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Real-time scheduling means a certain way to
schedule a fair and constant access to the CPU. Such a restriction
may not necessarily reduce the run time of a program.</p>
</div>
</li>
<li><p><u>Example</u>: <a class="reference internal" href="age_threads.html#code-age-threads"><span class="std std-ref">age_threads.cpp</span></a></p></li>
</ul>
</div>
<div class="section" id="thread-synchronization-with-mutex">
<h2><span class="section-number">2.2.3. </span>Thread synchronization with mutex<a class="headerlink" href="#thread-synchronization-with-mutex" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>If you run <a class="reference internal" href="age_threads.html#code-age-threads"><span class="std std-ref">age_threads.cpp</span></a>, the console printout
is not what you have expected. Despite the messages printed out by
different threads sometimes come out cleanly, they often garble
together. This is because the threads are running asynchronously
without regard of the existence of each other. The characters of the
message strings from different threads may be put into the buffer of
<code class="docutils literal notranslate"><span class="pre">std::cout</span></code> by the respective <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> operators in the threads in some
unpredictable order, garbling the output.</p></li>
<li><p>The situation can be worse when multiple threads are writing to the
same memory location that holds a pointer to an object. A race
condition may occur and the content of memory location may become
unpredictable. Any subsequent reference to the object may cause the
program to crash! The technical terminology to describe this situation is that
such an implementation is not <strong>thread-safe</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Strictly speaking, both <code class="docutils literal notranslate"><span class="pre">std::cout</span></code> and the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> operator are
thread-safe because the implementation indeed prevents multiple
threads from writing to the buffer of <code class="docutils literal notranslate"><span class="pre">std::cout</span></code>
simultaneously. In fact,  <a class="reference internal" href="age_threads.html#code-age-threads"><span class="std std-ref">age_threads.cpp</span></a>
doesn’t crash. However, this thread-safe property applies only on a
character-by-character basis; hence we still have the messages from
different threads garbled together.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p><strong>Neither <code class="docutils literal notranslate"><span class="pre">uhd::tx_streamer::send()</span></code> nor
<code class="docutils literal notranslate"><span class="pre">uhd::rx_streamer::recv()</span></code> is thread-safe.</strong></p>
</div>
</li>
<li><p>In order to make <a class="reference internal" href="age_threads.html#code-age-threads"><span class="std std-ref">age_threads.cpp</span></a> work in the way
as we want it to, we need to provide a form of synchronization among
all the threads that a thread can get exclusive access to
<code class="docutils literal notranslate"><span class="pre">std::cout</span></code>, blocking other threads from using <code class="docutils literal notranslate"><span class="pre">std::cout</span></code> before
the thread is done streaming its whole message to <code class="docutils literal notranslate"><span class="pre">std::cout</span></code>.</p></li>
<li><p><strong>Mutexes</strong> provide a basic mechanism for achieving this form of
synchronization among threads. We will use the <code class="docutils literal notranslate"><span class="pre">std::mutex</span></code> class to
construct mutexes.</p>
<div class="admonition-dig-deeper admonition">
<p class="admonition-title">Dig deeper</p>
<p>You may also use the more versatile <code class="docutils literal notranslate"><span class="pre">boost::mutex</span></code> class from the
<a class="reference external" href="https://www.boost.org/doc/libs/1_71_0/doc/html/thread.html">Boost.Thread</a>
library.</p>
</div>
</li>
<li><p>There are many ways to use mutexes for thread synchronization.
The following three simple ways are pretty much all needed for most
of our purposes.</p>
<div class="admonition-dig-deeper admonition">
<p class="admonition-title">Dig deeper</p>
<p>See this <a class="reference external" href="http://www.boost.org/doc/libs/1_71_0/doc/html/thread/synchronization.html">tutorial</a>
for a short introduction and <a class="bibtex reference internal" href="prelims_exs.html#williams2019" id="id1">[1]</a> for a more
detailed treatment.</p>
</div>
</li>
</ul>
<div class="section" id="internal-locking">
<h3><span class="section-number">2.2.3.1. </span>Internal locking<a class="headerlink" href="#internal-locking" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Consider</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SharedPrinter</span> <span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">message</span><span class="p">;</span>
        <span class="n">mtx</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span> 
</pre></div>
</div>
<p>which will be used in place of <code class="docutils literal notranslate"><span class="pre">std::cout</span></code> in
<a class="reference internal" href="age_threads.html#code-age-threads"><span class="std std-ref">age_threads.cpp</span></a></p>
</li>
<li><p>Suppose that a thread calls <code class="docutils literal notranslate"><span class="pre">SharedPrinter:print()</span></code>. The
<code class="docutils literal notranslate"><span class="pre">std::mutex::lock()</span></code> method in <code class="docutils literal notranslate"><span class="pre">SharedPrinter:print()</span></code> gives
ownership of the mutex <code class="docutils literal notranslate"> <span class="pre">SharedPrinter::mtx</span></code> to the thread, and
blocks other threads from accessing the object. After the whole
message is streamed to <code class="docutils literal notranslate"><span class="pre">std::cout</span></code>, the method
<code class="docutils literal notranslate"><span class="pre">std::mutex::unlock()</span></code> releases the current thread’s ownership of
the mutex, allowing other threads to access the <code class="docutils literal notranslate"><span class="pre">SharedPrinter</span></code>
object again. As a result, only one thread can stream a message to
<code class="docutils literal notranslate"><span class="pre">std::cout</span></code> at a time, and no other thread can stream to <code class="docutils literal notranslate"><span class="pre">std::cout</span></code>
until the current thread finishes streaming its whole message.</p></li>
<li><p>Note that <code class="docutils literal notranslate"><span class="pre">std::mutex::lock()</span></code> is a blocking call. It will return
until the mutex is unlocked by its current owner and the calling
thread obtains ownership of the mutex. The method
<code class="docutils literal notranslate"><span class="pre">std::mutex::try_lock()</span></code> attempts to obtain the mutex’s ownership
for the current thread without blocking and returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if
succeeds.</p></li>
<li><p>One may also use a <strong>scoped lock</strong> in the definition of <code class="docutils literal notranslate"><span class="pre">SharedPrinter</span></code>
in place of the explicit calling of <code class="docutils literal notranslate"><span class="pre">std::mutex::lock()</span></code> and
<code class="docutils literal notranslate"><span class="pre">std::mutex::lunlock()</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SharedPrinter</span> <span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span> 
    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">scoped_lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span> 
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">message</span><span class="p">;</span> 
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The object <code class="docutils literal notranslate"><span class="pre">scoped_lock</span></code>’s constructor and destructor locks and
releases the mutex, respectively.</p>
</li>
<li><p>Example code showing how to use <code class="docutils literal notranslate"><span class="pre">SharedPrinter</span></code>:
<a class="reference internal" href="age_mutex.html#code-age-mutex"><span class="std std-ref">age_mutex.cpp</span></a></p></li>
</ul>
</div>
<div class="section" id="caller-ensured-locking">
<h3><span class="section-number">2.2.3.2. </span>Caller-ensured locking<a class="headerlink" href="#caller-ensured-locking" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Consider the following implementation of the <code class="docutils literal notranslate"><span class="pre">SharedPrinter</span></code> class:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SharedPrinter</span> <span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">message</span><span class="p">;</span>
    <span class="p">}</span>
     <span class="kt">void</span> <span class="n">lock</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">unlock</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">mtx</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span> 
</pre></div>
</div>
<p>where the mutex locking and unlocking methods are exposed to the caller
function.  The class method <code class="docutils literal notranslate"><span class="pre">SharedPrinter::print()</span></code> is <strong>not</strong> thread-safe
and the caller is responsible for blocking other threads from
accessing it.</p>
</li>
<li><p>Example code showing how to use this caller-ensured locking version
of <code class="docutils literal notranslate"><span class="pre">SharedPrinter</span></code>: <a class="reference internal" href="age_mutex_caller.html#code-age-mutex-caller"><span class="std std-ref">age_mutex_caller.cpp</span></a></p></li>
</ul>
</div>
<div class="section" id="internal-caller-ensured-locking">
<h3><span class="section-number">2.2.3.3. </span>Internal + Caller-ensured locking<a class="headerlink" href="#internal-caller-ensured-locking" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>We may obtain the best of both methods above by the following
implementation of the <code class="docutils literal notranslate"><span class="pre">SharedPrinter</span></code> class:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SharedPrinter</span> <span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">recursive_mutex</span> <span class="n">mtx</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span> <span class="n">scoped_lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">message</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">lock</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">unlock</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">mtx</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>where the class method <code class="docutils literal notranslate"><span class="pre">SharedPrinter</span> <span class="pre">::print()</span></code> is now thread-safe.</p>
</li>
<li><p>Note that we have to use <code class="docutils literal notranslate"><span class="pre">std::recursive_mutex</span></code> in this implementation
to allow for the possibility of the same mutex being locked
repeatedly internally and by the caller.</p></li>
<li><div class="hint admonition">
<p class="admonition-title">Experiment</p>
<ol>
<li><p>Use this new implementation of <code class="docutils literal notranslate"><span class="pre">SharedPrinter</span></code> in
<a class="reference internal" href="age_mutex_caller.html#code-age-mutex-caller"><span class="std std-ref">age_mutex_caller.cpp</span></a>. Compile and run
your modified code to observe the results.</p></li>
<li><p>Instead of <code class="docutils literal notranslate"><span class="pre">std::recursive_mutex</span></code> in the implementation of
<code class="docutils literal notranslate"><span class="pre">SharedPrinter</span></code> above, use <code class="docutils literal notranslate"><span class="pre">std::mutex</span></code> to construct the scoped
clock. Compile and test the resulting code. Explain what happens.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>If the program hangs, don’t panic. You may press CTRL-Z to stop
it. Then run <code class="docutils literal notranslate"><span class="pre">ps</span></code> to find out its process number and <code class="docutils literal notranslate"><span class="pre">kill</span> <span class="pre">-9</span> <span class="pre">&lt;process</span> <span class="pre">number&gt;</span></code> to remove it.</p>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="passing-information-signal-between-threads-using-atomic-objects">
<h2><span class="section-number">2.2.4. </span>Passing information/signal between threads using atomic objects<a class="headerlink" href="#passing-information-signal-between-threads-using-atomic-objects" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Information and data may be passed between threads via shared
objects. The methods to access these shared objects should be
thread-safe. That can be achieved by employing the mutex-based
techniques discussed before.</p></li>
<li><p>When we want to share a variable of fundamental type, such as
<code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, and <em>etc</em>, we may effectively achieve
locking by declaring the variable as <code class="docutils literal notranslate"><span class="pre">atomic</span></code> using the
<code class="docutils literal notranslate"><span class="pre">std::atomic&lt;&gt;</span></code> template. An atomic object is free from data races.
If one thread writes to an atomic object while another thread reads
from it, the behavior is well-defined.</p></li>
<li><p>The basic methods to write to and read from an atomic variable are
<code class="docutils literal notranslate"><span class="pre">std::atomic::store()</span></code> and <code class="docutils literal notranslate"><span class="pre">std::atomic::load()</span></code>, respectively. One
may also use the <code class="docutils literal notranslate"><span class="pre">=</span></code> operator in place of
<code class="docutils literal notranslate"><span class="pre">std::atomic::store()</span></code>. Other operators, such as <code class="docutils literal notranslate"><span class="pre">++</span></code> and <code class="docutils literal notranslate"><span class="pre">--</span></code>, and
operation methods are also available for atomic objects. See
<a class="reference external" href="https://www.cplusplus.com/reference/atomic/atomic/">this link</a> for
details.</p>
<div class="admonition-dig-deeper admonition">
<p class="admonition-title">Dig deeper</p>
<p>An atomic object may be used to synchronize access to other
non-atomic objects near it in different threads by specifying
different memory orders. See <a class="bibtex reference internal" href="prelims_exs.html#williams2019" id="id2">[1]</a> for details. By
default, <code class="docutils literal notranslate"><span class="pre">std::atomic::store()</span></code> and <code class="docutils literal notranslate"><span class="pre">std::atomic::load()</span></code> employ the
strictest memory order. The <code class="docutils literal notranslate"><span class="pre">=</span></code> operator is equivalent to
<code class="docutils literal notranslate"><span class="pre">std::atomic::store()</span></code> with the strictest memory order.</p>
</div>
</li>
<li><p>One may also use atomic objects to pass signals from one thread to
others in order to trigger their operations.</p></li>
<li><p><u>Example:</u> <a class="reference internal" href="count_atomic.html#code-count-atomic"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">count_atomic.cpp</span></code></span></a></p>
<div class="admonition-dig-deeper admonition">
<p class="admonition-title">Dig deeper</p>
<p>A more sophisticated, CPU-efficient way to pass signals between
threads is to use mutexes together with condition variables. See
this
<a class="reference external" href="https://www.cplusplus.com/reference/condition_variable/condition_variable/">simple example </a>
and <a class="bibtex reference internal" href="prelims_exs.html#williams2019" id="id3">[1]</a> for a more detailed exploration.</p>
</div>
</li>
</ul>
</div>
<div class="section" id="thread-safe-fifo-queue">
<h2><span class="section-number">2.2.5. </span>Thread-safe FIFO queue<a class="headerlink" href="#thread-safe-fifo-queue" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>We will often encounter the common scenario in which the
output generated by a thread (threads) needs to be passed on to
another thread(s) for further processing. Since all threads are
running asynchronously, we need to provide thread-safe buffering
between the data-generating and data-receiving threads.</p></li>
<li><p>A simple example of such thread-safe buffering is the FIFO queue
implemented in the <code class="docutils literal notranslate"><span class="pre">MutexFIFO</span></code> class template defined in the header
file <a class="reference internal" href="queue.html#code-queue"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">queue.hpp</span></code></span></a>.</p></li>
<li><p><u>Example code</u> that shows how to use this FIFO
queue: <a class="reference internal" href="age_fifo.html#code-age-fifo"><span class="std std-ref">age_fifo.cpp</span></a></p></li>
<li><p>One should make sure that the arrival rate to the FIFO queue should
be smaller than its service rate. Otherwise the size of the queue
will grow and eventually cause memory problems.</p></li>
</ul>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="uhd.html" title="previous page"><span class="section-number">2.1. </span>UHD</a>
    <a class='right-next' id="next-link" href="prelims_exs.html" title="next page"><span class="section-number">2.3. </span>References and further reading</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Tan F. Wong<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="_static/js/index.3da636dd464baa7582d2.js"></script>


    
  </body>
</html>